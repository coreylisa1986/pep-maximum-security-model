<html><head><title>PEP X - Surving a Compromise of PyPI: The Maximum Security Model</title><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">.lst-kix_list_b-7>li:before{content:"\0025a0  "}.lst-kix_list_6-3>li:before{content:"\0025a0  "}.lst-kix_list_6-7>li:before{content:"\0025a0  "}ul.lst-kix_list_9-8{list-style-type:none}ul.lst-kix_list_9-7{list-style-type:none}ul.lst-kix_list_9-6{list-style-type:none}ul.lst-kix_list_9-5{list-style-type:none}ul.lst-kix_list_9-4{list-style-type:none}ul.lst-kix_list_9-3{list-style-type:none}ul.lst-kix_list_9-2{list-style-type:none}.lst-kix_list_6-2>li:before{content:"\0025a0  "}ul.lst-kix_list_9-1{list-style-type:none}ul.lst-kix_list_5-1{list-style-type:none}ul.lst-kix_list_5-2{list-style-type:none}ul.lst-kix_list_5-3{list-style-type:none}ul.lst-kix_list_5-4{list-style-type:none}.lst-kix_list_8-5>li:before{content:"\0025a0  "}.lst-kix_list_a-3>li:before{content:"\0025a0  "}ul.lst-kix_list_5-5{list-style-type:none}ul.lst-kix_list_5-6{list-style-type:none}ul.lst-kix_list_5-7{list-style-type:none}ol.lst-kix_list_a-0{list-style-type:none}ul.lst-kix_list_5-8{list-style-type:none}.lst-kix_list_b-8>li:before{content:"\0025a0  "}ul.lst-kix_list_7-8{list-style-type:none}ul.lst-kix_list_7-7{list-style-type:none}.lst-kix_list_c-8>li:before{content:"\0025a0  "}.lst-kix_list_4-3>li:before{content:"\0025a0  "}ul.lst-kix_list_7-4{list-style-type:none}ul.lst-kix_list_7-3{list-style-type:none}ul.lst-kix_list_7-6{list-style-type:none}ul.lst-kix_list_7-5{list-style-type:none}ol.lst-kix_list_c-0.start{counter-reset:lst-ctn-kix_list_c-0 0}ul.lst-kix_list_7-2{list-style-type:none}ul.lst-kix_list_7-1{list-style-type:none}ol.lst-kix_list_5-0.start{counter-reset:lst-ctn-kix_list_5-0 0}ul.lst-kix_list_b-8{list-style-type:none}.lst-kix_list_1-0>li{counter-increment:lst-ctn-kix_list_1-0}ul.lst-kix_list_b-4{list-style-type:none}ul.lst-kix_list_b-5{list-style-type:none}ul.lst-kix_list_b-6{list-style-type:none}ul.lst-kix_list_b-7{list-style-type:none}.lst-kix_list_3-6>li:before{content:"\0025a0  "}ul.lst-kix_list_b-1{list-style-type:none}ul.lst-kix_list_b-2{list-style-type:none}ul.lst-kix_list_b-3{list-style-type:none}ol.lst-kix_list_b-0{list-style-type:none}.lst-kix_list_5-2>li:before{content:"\0025a0  "}.lst-kix_list_9-1>li:before{content:"\0025cb  "}.lst-kix_list_b-5>li:before{content:"\0025a0  "}.lst-kix_list_6-8>li:before{content:"\0025a0  "}.lst-kix_list_c-0>li{counter-increment:lst-ctn-kix_list_c-0}.lst-kix_list_7-2>li:before{content:"\0025a0  "}ul.lst-kix_list_3-7{list-style-type:none}ul.lst-kix_list_3-8{list-style-type:none}.lst-kix_list_8-4>li:before{content:"\0025a0  "}.lst-kix_list_c-2>li:before{content:"\0025a0  "}.lst-kix_list_1-6>li:before{content:"\0025a0  "}ul.lst-kix_list_3-0{list-style-type:none}ul.lst-kix_list_3-1{list-style-type:none}ul.lst-kix_list_3-2{list-style-type:none}ul.lst-kix_list_3-3{list-style-type:none}ul.lst-kix_list_3-4{list-style-type:none}ul.lst-kix_list_3-5{list-style-type:none}ul.lst-kix_list_3-6{list-style-type:none}ul.lst-kix_list_1-2{list-style-type:none}ul.lst-kix_list_1-1{list-style-type:none}ul.lst-kix_list_1-4{list-style-type:none}ul.lst-kix_list_1-3{list-style-type:none}ul.lst-kix_list_1-6{list-style-type:none}ul.lst-kix_list_1-5{list-style-type:none}ul.lst-kix_list_1-8{list-style-type:none}ul.lst-kix_list_1-7{list-style-type:none}.lst-kix_list_2-1>li:before{content:"\0025cb  "}ol.lst-kix_list_1-0{list-style-type:none}.lst-kix_list_4-8>li:before{content:"\0025a0  "}.lst-kix_list_5-5>li:before{content:"\0025a0  "}.lst-kix_list_9-3>li:before{content:"\0025a0  "}.lst-kix_list_9-6>li:before{content:"\0025a0  "}.lst-kix_list_2-0>li:before{content:"\0025cf  "}ol.lst-kix_list_8-0.start{counter-reset:lst-ctn-kix_list_8-0 0}.lst-kix_list_9-2>li:before{content:"\0025a0  "}.lst-kix_list_b-6>li:before{content:"\0025a0  "}.lst-kix_list_2-4>li:before{content:"\0025a0  "}.lst-kix_list_4-2>li:before{content:"\0025a0  "}ul.lst-kix_list_6-1{list-style-type:none}ul.lst-kix_list_6-0{list-style-type:none}ul.lst-kix_list_6-3{list-style-type:none}.lst-kix_list_a-6>li:before{content:"\0025a0  "}ul.lst-kix_list_6-2{list-style-type:none}.lst-kix_list_a-4>li:before{content:"\0025a0  "}ul.lst-kix_list_6-5{list-style-type:none}.lst-kix_list_a-0>li:before{content:"" counter(lst-ctn-kix_list_a-0,decimal) ". "}ul.lst-kix_list_6-4{list-style-type:none}ul.lst-kix_list_6-7{list-style-type:none}.lst-kix_list_4-1>li:before{content:"\0025cb  "}ul.lst-kix_list_6-6{list-style-type:none}ul.lst-kix_list_6-8{list-style-type:none}ol.lst-kix_list_1-0.start{counter-reset:lst-ctn-kix_list_1-0 0}ol.lst-kix_list_5-0{list-style-type:none}.lst-kix_list_1-0>li:before{content:"" counter(lst-ctn-kix_list_1-0,decimal) ". "}.lst-kix_list_5-8>li:before{content:"\0025a0  "}ol.lst-kix_list_4-0{list-style-type:none}.lst-kix_list_a-7>li:before{content:"\0025a0  "}ul.lst-kix_list_c-8{list-style-type:none}.lst-kix_list_3-4>li:before{content:"\0025a0  "}ul.lst-kix_list_c-7{list-style-type:none}.lst-kix_list_1-3>li:before{content:"\0025a0  "}.lst-kix_list_8-3>li:before{content:"\0025a0  "}ul.lst-kix_list_c-2{list-style-type:none}ul.lst-kix_list_c-1{list-style-type:none}ul.lst-kix_list_c-4{list-style-type:none}ul.lst-kix_list_c-3{list-style-type:none}ul.lst-kix_list_c-6{list-style-type:none}.lst-kix_list_8-1>li:before{content:"\0025cb  "}ul.lst-kix_list_c-5{list-style-type:none}ol.lst-kix_list_8-0{list-style-type:none}ul.lst-kix_list_a-1{list-style-type:none}ul.lst-kix_list_a-2{list-style-type:none}ul.lst-kix_list_a-3{list-style-type:none}.lst-kix_list_6-0>li:before{content:"\0025cf  "}ul.lst-kix_list_a-4{list-style-type:none}ul.lst-kix_list_a-5{list-style-type:none}ul.lst-kix_list_a-6{list-style-type:none}ul.lst-kix_list_a-7{list-style-type:none}ul.lst-kix_list_a-8{list-style-type:none}.lst-kix_list_4-0>li{counter-increment:lst-ctn-kix_list_4-0}.lst-kix_list_c-6>li:before{content:"\0025a0  "}ol.lst-kix_list_9-0{list-style-type:none}.lst-kix_list_4-0>li:before{content:"" counter(lst-ctn-kix_list_4-0,decimal) ". "}.lst-kix_list_b-2>li:before{content:"\0025a0  "}.lst-kix_list_7-8>li:before{content:"\0025a0  "}.lst-kix_list_3-1>li:before{content:"\0025cb  "}.lst-kix_list_8-7>li:before{content:"\0025a0  "}ul.lst-kix_list_2-4{list-style-type:none}ul.lst-kix_list_2-5{list-style-type:none}ul.lst-kix_list_2-6{list-style-type:none}.lst-kix_list_1-7>li:before{content:"\0025a0  "}ul.lst-kix_list_2-7{list-style-type:none}ul.lst-kix_list_2-0{list-style-type:none}ul.lst-kix_list_2-1{list-style-type:none}ul.lst-kix_list_2-2{list-style-type:none}ul.lst-kix_list_2-3{list-style-type:none}.lst-kix_list_5-1>li:before{content:"\0025cb  "}ul.lst-kix_list_2-8{list-style-type:none}.lst-kix_list_9-7>li:before{content:"\0025a0  "}.lst-kix_list_7-3>li:before{content:"\0025a0  "}.lst-kix_list_1-1>li:before{content:"\0025cb  "}.lst-kix_list_a-5>li:before{content:"\0025a0  "}.lst-kix_list_3-2>li:before{content:"\0025a0  "}ol.lst-kix_list_4-0.start{counter-reset:lst-ctn-kix_list_4-0 0}.lst-kix_list_1-2>li:before{content:"\0025a0  "}.lst-kix_list_8-6>li:before{content:"\0025a0  "}.lst-kix_list_7-0>li{counter-increment:lst-ctn-kix_list_7-0}.lst-kix_list_1-5>li:before{content:"\0025a0  "}.lst-kix_list_b-0>li:before{content:"" counter(lst-ctn-kix_list_b-0,decimal) ". "}.lst-kix_list_a-8>li:before{content:"\0025a0  "}.lst-kix_list_2-3>li:before{content:"\0025a0  "}.lst-kix_list_1-4>li:before{content:"\0025a0  "}.lst-kix_list_5-7>li:before{content:"\0025a0  "}.lst-kix_list_9-4>li:before{content:"\0025a0  "}.lst-kix_list_2-7>li:before{content:"\0025a0  "}.lst-kix_list_1-8>li:before{content:"\0025a0  "}.lst-kix_list_b-1>li:before{content:"\0025cb  "}ol.lst-kix_list_a-0.start{counter-reset:lst-ctn-kix_list_a-0 0}.lst-kix_list_b-4>li:before{content:"\0025a0  "}.lst-kix_list_3-3>li:before{content:"\0025a0  "}.lst-kix_list_a-1>li:before{content:"\0025cb  "}.lst-kix_list_a-0>li{counter-increment:lst-ctn-kix_list_a-0}.lst-kix_list_c-5>li:before{content:"\0025a0  "}ol.lst-kix_list_b-0.start{counter-reset:lst-ctn-kix_list_b-0 0}.lst-kix_list_c-4>li:before{content:"\0025a0  "}.lst-kix_list_6-4>li:before{content:"\0025a0  "}.lst-kix_list_6-1>li:before{content:"\0025cb  "}.lst-kix_list_9-5>li:before{content:"\0025a0  "}.lst-kix_list_4-7>li:before{content:"\0025a0  "}.lst-kix_list_5-0>li{counter-increment:lst-ctn-kix_list_5-0}.lst-kix_list_2-6>li:before{content:"\0025a0  "}.lst-kix_list_6-5>li:before{content:"\0025a0  "}.lst-kix_list_9-0>li{counter-increment:lst-ctn-kix_list_9-0}.lst-kix_list_c-0>li:before{content:"" counter(lst-ctn-kix_list_c-0,decimal) ". "}.lst-kix_list_2-2>li:before{content:"\0025a0  "}.lst-kix_list_7-7>li:before{content:"\0025a0  "}.lst-kix_list_7-1>li:before{content:"\0025cb  "}.lst-kix_list_9-0>li:before{content:"" counter(lst-ctn-kix_list_9-0,decimal) ". "}.lst-kix_list_2-8>li:before{content:"\0025a0  "}.lst-kix_list_3-7>li:before{content:"\0025a0  "}.lst-kix_list_6-6>li:before{content:"\0025a0  "}.lst-kix_list_a-2>li:before{content:"\0025a0  "}.lst-kix_list_c-1>li:before{content:"\0025cb  "}.lst-kix_list_c-7>li:before{content:"\0025a0  "}.lst-kix_list_7-0>li:before{content:"" counter(lst-ctn-kix_list_7-0,decimal) ". "}.lst-kix_list_3-5>li:before{content:"\0025a0  "}ol.lst-kix_list_7-0.start{counter-reset:lst-ctn-kix_list_7-0 0}.lst-kix_list_9-8>li:before{content:"\0025a0  "}ul.lst-kix_list_8-4{list-style-type:none}ul.lst-kix_list_8-5{list-style-type:none}ul.lst-kix_list_8-2{list-style-type:none}ul.lst-kix_list_8-3{list-style-type:none}ul.lst-kix_list_8-8{list-style-type:none}.lst-kix_list_c-3>li:before{content:"\0025a0  "}.lst-kix_list_8-0>li:before{content:"" counter(lst-ctn-kix_list_8-0,decimal) ". "}ul.lst-kix_list_8-6{list-style-type:none}.lst-kix_list_4-6>li:before{content:"\0025a0  "}ul.lst-kix_list_8-7{list-style-type:none}.lst-kix_list_5-3>li:before{content:"\0025a0  "}.lst-kix_list_4-5>li:before{content:"\0025a0  "}ul.lst-kix_list_8-1{list-style-type:none}.lst-kix_list_3-0>li:before{content:"\0025cf  "}.lst-kix_list_2-5>li:before{content:"\0025a0  "}.lst-kix_list_7-6>li:before{content:"\0025a0  "}ol.lst-kix_list_c-0{list-style-type:none}.lst-kix_list_5-4>li:before{content:"\0025a0  "}ol.lst-kix_list_7-0{list-style-type:none}.lst-kix_list_4-4>li:before{content:"\0025a0  "}ol.lst-kix_list_9-0.start{counter-reset:lst-ctn-kix_list_9-0 0}.lst-kix_list_7-4>li:before{content:"\0025a0  "}.lst-kix_list_b-0>li{counter-increment:lst-ctn-kix_list_b-0}.lst-kix_list_8-0>li{counter-increment:lst-ctn-kix_list_8-0}.lst-kix_list_5-0>li:before{content:"" counter(lst-ctn-kix_list_5-0,decimal) ". "}ul.lst-kix_list_4-8{list-style-type:none}ul.lst-kix_list_4-7{list-style-type:none}ul.lst-kix_list_4-6{list-style-type:none}ul.lst-kix_list_4-1{list-style-type:none}.lst-kix_list_7-5>li:before{content:"\0025a0  "}ul.lst-kix_list_4-5{list-style-type:none}ul.lst-kix_list_4-4{list-style-type:none}ul.lst-kix_list_4-3{list-style-type:none}.lst-kix_list_3-8>li:before{content:"\0025a0  "}ul.lst-kix_list_4-2{list-style-type:none}.lst-kix_list_5-6>li:before{content:"\0025a0  "}.lst-kix_list_8-2>li:before{content:"\0025a0  "}.lst-kix_list_b-3>li:before{content:"\0025a0  "}.lst-kix_list_8-8>li:before{content:"\0025a0  "}ol{margin:0;padding:0}.c4{border-bottom-width:1pt;border-top-style:solid;width:117pt;border-right-style:solid;border-bottom-color:#000000;border-top-width:1pt;border-bottom-style:solid;vertical-align:top;border-top-color:#000000;border-left-color:#000000;border-right-color:#000000;border-left-style:solid;border-right-width:1pt;border-left-width:1pt}.c5{vertical-align:baseline;color:#000000;font-size:11pt;font-style:normal;font-family:"Arial";text-decoration:none;font-weight:normal}.c18{vertical-align:baseline;color:#000000;font-size:11pt;font-style:normal;font-family:"Arial";text-decoration:none}.c11{line-height:1.0;padding-top:0pt;text-align:left;padding-bottom:0pt}.c19{max-width:468pt;background-color:#ffffff;padding:72pt 72pt 72pt 72pt}.c9{list-style-position:inside;text-indent:45pt;margin-left:30pt}.c3{vertical-align:super;color:#0000ee;text-decoration:underline}.c17{margin-right:auto;border-collapse:collapse}.c0{margin:0;padding:0}.c10{color:#0000ee;text-decoration:underline}.c8{color:inherit;text-decoration:inherit}.c6{height:0pt}.c2{height:11pt}.c13{padding-bottom:12pt}.c12{padding-top:0pt}.c1{direction:ltr}.c15{padding-bottom:11.2pt}.c14{font-weight:bold}.c16{margin-left:30pt}.c7{font-style:italic}.title{padding-top:24pt;line-height:1.0;text-align:left;color:#000000;font-size:36pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt;page-break-after:avoid}.subtitle{padding-top:18pt;line-height:1.0;text-align:left;color:#666666;font-style:italic;font-size:24pt;font-family:"Georgia";padding-bottom:4pt;page-break-after:avoid}li{color:#000000;font-size:11pt;font-family:"Arial"}p{color:#000000;font-size:11pt;margin:0;font-family:"Arial"}h1{padding-top:12pt;line-height:1.0;text-align:left;color:#000000;font-size:24pt;font-family:"Arial";font-weight:bold;padding-bottom:12pt}h2{padding-top:11.2pt;line-height:1.0;text-align:left;color:#000000;font-size:18pt;font-family:"Arial";font-weight:bold;padding-bottom:11.2pt}h3{padding-top:12pt;line-height:1.0;text-align:left;color:#000000;font-size:14pt;font-family:"Arial";font-weight:bold;padding-bottom:12pt}h4{padding-top:12.8pt;line-height:1.0;text-align:left;color:#000000;font-size:12pt;font-family:"Arial";font-weight:bold;padding-bottom:12.8pt}h5{padding-top:12.8pt;line-height:1.0;text-align:left;color:#000000;font-size:9pt;font-family:"Arial";font-weight:bold;padding-bottom:12.8pt}h6{padding-top:18pt;line-height:1.0;text-align:left;color:#000000;font-size:8pt;font-family:"Arial";font-weight:bold;padding-bottom:18pt}</style></head><body class="c19"><p class="c1"><span>Title: Surviving a Compromise of PyPI: The Maximum Security Model Version: $Revision$ Last-Modified: $Date$ Author: Trishank Karthik Kuppusamy &lt;trishank at nyu dot edu&gt;, Donald Stufft &lt;donald at stufft dot io&gt;, Justin Cappos &lt;jcappos at nyu dot edu&gt;, Vladimir Diaz &lt;vladimir.v.diaz at gmail dot com&gt;</span></p><p class="c13 c1"><span>BDFL-Delegate: Nick Coghlan &lt;ncoghlan at gmail dot com&gt; Discussions-To: DistUtils mailing list &lt;distutils-sig at python dot org&gt; Status: Draft Type: Standards Track Content-Type: text/x-rst Created: 8-Oct-2014 Replaces: 458</span></p><h1 class="c12 c1"><span>Abstract</span></h1><p class="c1"><span>Proposed is an extension to PEP 458 that adds support for end-to-end signing and the maximum security model. End-to-end signing allows both PyPI and developers to sign for the distributions that are downloaded by clients. The minimum security model proposed by PEP 458 supports continuous delivery of distributions (because they are signed by online keys), but that model does not protect distributions in the event that PyPI is compromised. The maximum security model retains many of the benefits of PEP 458 (e.g., immediate availability of distributions that are uploaded to PyPI) and additionally aims to ensure that PyPI can recover from a key compromise.</span></p><p class="c2 c1"><span></span></p><p class="c1 c13"><span>This PEP includes the changes made to PEP 458 but excludes its informational elements to primarily focus on the maximum security model. For example, an overview of The Update Framework is not covered here. The changes to PEP 458 include modifications to the snapshot process, key compromise analysis, auditing snapshots, and the steps that should be taken in the event of a PyPI compromise. The signing and key management process followed by developers that PyPI MAY RECOMMEND is discussed but not strictly defined. How the release process should be implemented to manage keys and metadata is left to the implementors of the signing tools. That is, this PEP delineates the expected cryptographic key type and signature format included in metadata that MUST be uploaded by developers in order to support end-to-end verification of distributions.</span></p><h1 class="c12 c1"><span>Rationale</span></h1><p class="c1"><span>PEP 458 </span><span class="c3">1</span><span>&nbsp;proposes how PyPI should be integrated with The Update Framework (TUF) </span><span class="c3">2</span><span>. It explains how modern package managers like pip can be made more secure, and the types of attacks that could be prevented if PyPI were modified on the server side to include TUF metadata. Package managers can reference the TUF metadata available on PyPI to download distributions more securely.</span></p><p class="c2 c1"><span></span></p><p class="c1"><span>PEP 458 also describes the metadata layout of the PyPI repository and the minimum security model. Although the minimum security model protects against most software update attacks, such as mix-and-match and extraneous dependencies attacks, it can be improved to also support end-to-end signing and to prohibit forged distributions if PyPI is compromised.</span></p><p class="c2 c1"><span></span></p><p class="c1"><span>The minimum security model supports continuous delivery of projects and uses online cryptographic keys to sign the distributions uploaded by projects. The main strength of the minimum security model is the automated and simplified release process: developers may upload distributions and then have PyPI sign for their distributions. Much of the release process is handled in an automated fashion by online roles and this simplified approach requires that cryptographic signing keys be stored on the PyPI infrastructure. Unfortunately, cryptographic keys that are stored online are vulnerable to theft, and thus distributions that are signed by these keys can be easily forged if attackers compromise the servers that sign for distributions.</span></p><p class="c2 c1"><span></span></p><p class="c1"><span>The maximum security model is an extension to the minimum model that allows PyPI to survive a repository compromise and permits developers to sign for the distributions that they make available to PyPI users. The maximum security provides additional protections while still supporting continuous delivery of distributions. However, for the following reasons, it is postponed and covered in this PEP instead of PEP 458:</span></p><p class="c2 c1"><span></span></p><ol class="c0 lst-kix_list_1-0 start" start="1"><li class="c9 c1"><span>A build farm (distribution wheels on supported platforms are generated on PyPI infrastructure for each project) may possibly complicate matters. PyPI wants to support a build farm in the future. Unfortunately, if wheels are auto-generated externally, developer signatures for these wheels are unlikely. However, there might still be a benefit to generating wheels from source distributions that are signed by developers (provided that reproducible wheels are possible). Another possibility is to optionally delegate trust of these wheels to an online role.</span></li><li class="c9 c1"><span>An easy-to-use key management solution is needed for developers. miniLock is one likely candidate for management and generation of keys. Although developer signatures can remain optional, this approach may be inadequate due to the great number of potentially unsigned dependencies for distributions a client may request. Requiring developers to manually sign distributions and manage keys is expected to render key signing an unused feature.</span></li><li class="c9 c1"><span>A two-phase approach, where the minimum security model is implemented before the maximum security model, will simplify matters and give PyPI administrators time to review the feasibility of end-to-end signing.</span></li></ol><h1 class="c1"><span>Threat Model</span></h1><p class="c1"><span>The threat model assumes the following:</span></p><ul class="c0 lst-kix_list_2-0 start"><li class="c9 c1"><span>Offline keys are safe and securely stored.</span></li><li class="c9 c1"><span>Attackers can compromise at least one of PyPI&#39;s trusted keys that are stored online, and may do so at once or over a period of time.</span></li><li class="c9 c1"><span>Attackers can respond to client requests.</span></li></ul><p class="c2 c1"><span></span></p><p class="c1"><span>Attackers are considered successful if they can cause a client to install (or leave installed) something other than the most up-to-date version of the</span></p><p class="c13 c1"><span>software the client is updating. When an attacker is preventing the installation of updates, the attacker&#39;s goal is that clients </span><span class="c7">not</span><span>&nbsp;realize that anything is wrong.</span></p><h1 class="c12 c1"><span>Definitions</span></h1><p class="c1"><span>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be interpreted as described in RFC </span><span class="c10"><a class="c8" href="http://www.google.com/url?q=http%3A%2F%2Fwww.ietf.org%2Frfc%2Frfc2119.txt&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNHXjIbC6KvT6ag4nc_COAXF7moB5w">2119</a></span><span>.</span></p><p class="c2 c1"><span></span></p><p class="c1"><span>This PEP focuses on integrating TUF with PyPI; however, the reader is encouraged to read about TUF&#39;s design principles </span><span class="c3">3</span><span>. It is also RECOMMENDED that the reader be familiar with the TUF specification </span><span class="c3">4</span><span>, and PEP 458 </span><span class="c3">5</span><span>&nbsp;(which this PEP is extending).</span></p><p class="c2 c1"><span></span></p><p class="c1"><span>Terms used in this PEP are defined as follows:</span></p><p class="c2 c1"><span></span></p><ul class="c0 lst-kix_list_3-0 start"><li class="c9 c1"><span>Projects: Projects are software components that are made available for integration. Projects include Python libraries, frameworks, scripts, plugins, applications, collections of data or other resources, and various combinations thereof. Public Python projects are typically registered on the Python Package Index </span><span class="c3">6</span><span>.</span></li><li class="c9 c1"><span>Releases: Releases are uniquely identified snapshots of a project </span><span class="c3">7</span><span>.</span></li><li class="c9 c1"><span>Distributions: Distributions are the packaged files that are used to publish</span></li><li class="c9 c1"><span>Simple index: The HTML page that contains internal links to the distributions of a project </span><span class="c3">8</span><span>.</span></li><li class="c9 c1"><span>Roles: There is one </span><span class="c7">root</span><span>&nbsp;role in PyPI. There are multiple roles whose responsibilities are delegated to them directly or indirectly by the </span><span class="c7">root</span><span>&nbsp;role. The term top-level role refers to the </span><span class="c7">root</span><span>&nbsp;role and any role delegated by the </span><span class="c7">root</span><span>&nbsp;role. Each role has a single metadata file that it is trusted to provide.</span></li><li class="c9 c1"><span>Metadata: Metadata are files that describe roles, other metadata, and target files.</span></li><li class="c1"><span>Repository: A repository is a resource comprised of named metadata and target files. Clients request metadata and target files stored on a repository.</span></li><li class="c9 c1"><span>Consistent snapshot: A set of TUF metadata and PyPI targets that capture the complete state of all projects on PyPI as they existed at some fixed point in time.</span></li><li class="c9 c1"><span>The </span><span class="c7">snapshot</span><span>&nbsp;(</span><span class="c7">release</span><span>) role: In order to prevent confusion due to the different meanings of the term &quot;release&quot; used in PEP 426 </span><span class="c3">9</span><span>&nbsp;and the TUF specification </span><span class="c3">10</span><span>, the </span><span class="c7">release</span><span>&nbsp;role is renamed to the </span><span class="c7">snapshot</span><span>&nbsp;role.</span></li><li class="c9 c1"><span>Developer: Either the owner or maintainer of a project who is allowed to update TUF metadata as well as distribution metadata and files for a given project.</span></li><li class="c9 c1"><span>Online key: A private cryptographic key that MUST be stored on the PyPI server infrastructure. This usually allows automated signing with the key. An attacker who compromises the PyPI infrastructure will be able to immediately read these keys.</span></li><li class="c9 c1"><span>Offline key: A private cryptographic key that MUST be stored independent of the PyPI server infrastructure. This prevents automated signing with the key. An attacker who compromises the PyPI infrastructure will not be able to immediately read these keys.</span></li><li class="c9 c1"><span>Threshold signature scheme: A role can increase its resilience to key compromises by specifying that at least t out of n keys are REQUIRED to sign its metadata. A compromise of t-1 keys is insufficient to compromise the role itself. Saying that a role requires (t, n) keys denotes the threshold signature property.</span></li></ul><h1 class="c1"><span>Maximum Security Model</span></h1><p class="c1"><span>The maximum security model permits developers to sign their projects and upload signed metadata to PyPI. If the PyPI infrastructure were to be compromised, attackers would be unable to serve malicious versions of a </span><span class="c7">claimed</span><span>&nbsp;project without having access to that project&#39;s developer key. Figure 1 depicts the changes made to the metadata layout of the minimum security model, namely that developer roles are now supported and that three new delegated roles exist: </span><span class="c7">claimed</span><span>, </span><span class="c7">recently-claimed</span><span>, and </span><span class="c7">unclaimed</span><span>. The </span><span class="c7">bins</span><span>&nbsp;role has been renamed </span><span class="c7">unclaimed</span><span>&nbsp;and can contain any projects that have not been added to </span><span class="c7">claimed</span><span>. The </span><span class="c7">unclaimed</span><span>&nbsp;role functions just as before (i.e., as explained in PEP 458, projects added to this role are signed by PyPI with an online key). Offline keys provided by developers ensure the strength of the maximum security model over the minimum model. Although the minimum security model supports continuous delivery of projects, all projects are signed by an online key. That is, an attacker is able to corrupt packages in the minimum security model, but not in the maximum model, without also compromising a developer&#39;s key.</span></p><p class="c2 c1"><span></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="figure1.png" src="images/image00.png" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2 c1"><span></span></p><p class="c1"><span>Figure 1: An overview of the metadata layout in the maximum security model. The maximum security model supports continuous delivery and survivable key compromise.</span></p><p class="c2 c13 c1"><span></span></p><p class="c13 c1"><span>Projects that are signed by developers and uploaded to PyPI for the first time are added to the </span><span class="c7">recently-claimed</span><span>&nbsp;role. The </span><span class="c7">recently-claimed</span><span>&nbsp;role uses an online key, so projects uploaded for the first time are immediately available to clients. After some time has passed, PyPI administrators MAY move projects listed in </span><span class="c7">recently-claimed</span><span>&nbsp;to the </span><span class="c7">claimed</span><span>&nbsp;role for maximum security. The </span><span class="c7">claimed</span><span>&nbsp;role uses an offline key, thus projects added to this role cannot be easily forged if PyPI is compromised.</span></p><h1 class="c1 c12"><span>End-to-End Signing</span></h1><p class="c13 c1"><span>End-to-end signing allows both PyPI and developers to sign for the metadata downloaded by clients. PyPI is trusted to make uploaded projects available to clients (PyPI signs the metadata for this part of the process), and developers sign the distributions that they upload.</span></p><h1 class="c12 c1"><span>Metadata Signatures, Key Management, and Signing Distributions</span></h1><p class="c1 c15"><span>This section discusses the tools, signature schemes, and signing methods that PyPI MAY recommend to implementors of the signing tools. Developers are expected to use these tools to sign and upload distributions to PyPI. To summarize, developers MAY generate cryptographic keys and sign metadata in some automated fashion, where the metadata includes the information required to verify the authenticity of the distribution. The metadata is then uploaded to PyPI by the developer, where it will be available for download by package managers such as pip (i.e., package managers that support TUF metadata). The entire process is transparent to end-users (using a package manager that supports TUF) who download distributions from PyPI.</span></p><h2 class="c12 c1"><span>Cryptographic Signature Scheme: Ed25519</span></h2><p class="c1"><span>The package manager shipped with CPython (pip) MUST work on non-CPython interpreters and cannot have dependencies that have to be compiled (i.e., the PyPI+TUF integration MUST NOT require compilation of C extensions in order to verify cryptographic signatures). Verification of signatures MUST be done in Python, and verifying RSA signatures in pure-Python may be impractical due to speed. Therefore, PyPI MAY use the </span><span class="c10"><a class="c8" href="http://www.google.com/url?q=http%3A%2F%2Fed25519.cr.yp.to%2F&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNE3WWdh9ehNZ0LLWd9EhunRCbTgQw">Ed25519</a></span><span>&nbsp;signature scheme.</span></p><p class="c2 c1"><span></span></p><p class="c1 c15"><span>Ed25519 is a public-key signature system that uses small cryptographic signatures and keys. A pure-Python implementation of the Ed25519 signature scheme is available. Verification of Ed25519 signatures is fast, even when performed in Python.</span></p><h2 class="c12 c1"><span>Cryptographic Key Files</span></h2><p class="c1 c15"><span>The implementation MAY encrypt key files with AES-256-CTR-Mode and strengthen passwords with PBKDF2-HMAC-SHA256 (100K iterations by default, but this may be overridden by the developer). The current Python implementation of TUF can use any cryptographic library (support for PyCA cryptography will be added in the future), may override the default number of PBKDF2 iterations, and the KDF tweaked to taste.</span></p><h2 class="c12 c1"><span>Key Management: miniLock</span></h2><p class="c1 c15"><span>A key management solution that uses miniLock derives a private key from a password so that developers do not have to manage cryptographic key files across multiple computers. Developers may view the cryptographic key as a secondary password. miniLock also works well with a signature scheme like Ed25519, which only needs a very small key.</span></p><h2 class="c12 c1"><span>Third-party Upload Tools: Twine</span></h2><p class="c1 c15"><span>Third-party tools like </span><span class="c10"><a class="c8" href="https://www.google.com/url?q=https%3A%2F%2Fgithub.com%2Fpyca%2Fed25519&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNFPVyuqwjYOzguAd4wHST1c9Pn0Gw">Twine</a></span><span>&nbsp;may be modified (if they wish to support distributions that include TUF metadata) to sign and upload developer projects to PyPI. Twine is a utility for interacting with PyPI that uses TLS to upload distributions, and prevents MITM attacks on usernames and passwords.</span></p><h2 class="c12 c1"><span>Distutils</span></h2><p class="c1 c15"><span>Distutils MAY be modified to sign metadata and to upload signed distributions to PyPI. Distutils comes packaged with CPython and is the most widely-used tool for uploading distributions to PyPI.</span></p><h2 class="c12 c1"><span>Automated Signing Solution</span></h2><p class="c1"><span>A default PyPI-mediated key management and package signing solution that is transparent to developers and does not require a key escrow (sharing encrypted private keys with PyPI) is RECOMMENDED for the signing tools. Additionally, the signing tools SHOULD also circumvent the sharing of encrypted private keys between the multiple machines of each developer.</span></p><p class="c2 c1"><span></span></p><p class="c1"><span>The following outlines the automated signing solution that a developer MAY follow to upload a distribution to PyPI:</span></p><p class="c2 c1"><span></span></p><ol class="c0 lst-kix_list_4-0 start" start="1"><li class="c9 c1"><span>Register project.</span></li><li class="c9 c1"><span>Enter secondary password.</span></li><li class="c9 c1"><span>Add new identity to user account from machine 2 (after a password prompt).</span></li><li class="c9 c1"><span>Upload project.</span></li></ol><p class="c2 c1"><span></span></p><p class="c1"><span>Under the hood (the developer is not aware or needs to care that packages are automatically signed):</span></p><p class="c2 c1"><span></span></p><p class="c1"><span>The &quot;create an identity with only a password&quot; action generates an encrypted private key file that uploads the ed25519 public key to PyPI. An existing identity (its public key is contained in project metadata or on PyPI) signs (this is done transparently) for new identities. By default, project metadata has a signature threshold of 1 and other verified identities may create new releases to satisfy the threshold.</span></p><p class="c2 c1"><span></span></p><p class="c1"><span>However, the signing tools should be flexible; a single project key may also be shared between multiple machines if manual key management is preferred (e.g., ssh-copy-id).</span></p><p class="c2 c1"><span></span></p><p class="c1"><span>The current TUF </span><span class="c10"><a class="c8" href="https://www.google.com/url?q=https%3A%2F%2Fgithub.com%2Fkaepora%2FminiLock%23-minilock&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNHvBq2Yv7pvxqcc4FKrxd6cyjxDEQ">repository</a></span><span>&nbsp;and </span><span class="c10"><a class="c8" href="https://www.google.com/url?q=https%3A%2F%2Fgithub.com%2Fpypa%2Ftwine&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNHTj00rZp3W7ZMG8Qg9eaoN6fR9dA">developer</a></span><span>&nbsp;tools are available for review:</span></p><p class="c1 c15"><span>The two signing tools above currently support all of the recommendations previously mentioned except for the automated signing solution, which must be added to Distutils, Twine, and other third-party signing tools. The automated signing solution simply calls available repository tool functions to sign metadata and generate the cryptographic key files.</span></p><h2 class="c12 c1"><span>Producing Consistent Snapshots</span></h2><p class="c1"><span>PyPI is responsible for updating, depending on the project, either the </span><span class="c7">claimed</span><span>, </span><span class="c7">recently-claimed</span><span>, or </span><span class="c7">unclaimed</span><span>&nbsp;metadata as well as associated delegated metadata metadata. Every project MUST upload its set of metadata and targets in a single transaction. The uploaded set of files is called the &quot;project transaction.&quot; How PyPI MAY validate files in a project transaction is discussed in a later section. The focus of this section is on how PyPI will respond to a project transaction.</span></p><p class="c2 c1"><span></span></p><p class="c1"><span>Every metadata and target file MUST include in its filename the </span><span class="c10"><a class="c8" href="https://www.google.com/url?q=https%3A%2F%2Fdocs.python.org%2F2%2Fdistutils%2Findex.html%23distutils-index&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNHraZv8PP3NzVqUnf9aNhqxaUJN0g">hex digest</a></span><span>&nbsp;of its </span><span class="c10"><a class="c8" href="https://www.google.com/url?q=https%3A%2F%2Fgithub.com%2Ftheupdateframework%2Ftuf%2Fblob%2Fdevelop%2Ftuf%2FREADME.md&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNH-5WMN2O6mphOxWxbF8BB3-fDlJA">SHA-256</a></span><span>&nbsp;hash. For this PEP, it is RECOMMENDED that PyPI adopt a simple convention of the form: digest.filename, where filename is the original filename without a copy of the hash, and digest is the hex digest of the hash.</span></p><p class="c1 c2"><span></span></p><p class="c1"><span>When an unclaimed project uploads a new transaction, a project transaction process MUST add all new targets and relevant delegated unclaimed metadata. (We describe later in this section why the unclaimed role will delegate targets to a number of delegated unclaimed roles.) Finally, the project transaction process MUST inform the consistent snapshot process about new delegated unclaimed metadata.</span></p><p class="c2 c1"><span></span></p><p class="c1"><span>When a recently-claimed project uploads a new a transaction, a project transaction process MUST add all new targets and delegated targets metadata for the project. If the project is new, then the project transaction process MUST also add new recently-claimed metadata with the public keys and threshold number (which MUST be part of the transaction) for the project. Finally, the project transaction process MUST inform the consistent snapshot process about new recently-claimed metadata as well as the current set of delegated targets metadata for the project.</span></p><p class="c2 c1"><span></span></p><p class="c1"><span>The transaction process for a claimed project is slightly different in that PyPI administrators will choose to move the project from the </span><span class="c7">recently-claimed</span><span>&nbsp;role to the </span><span class="c7">claimed</span><span>&nbsp;role. A project transaction process MUST then add new recently-claimed and claimed metadata to reflect this migration. As is the case for a recently-claimed project, the project transaction process MUST always add all new targets and delegated targets metadata for the claimed project. Finally, the project transaction process MUST inform the consistent snapshot process about new recently-claimed or claimed metadata as well as the current set of delegated targets metadata for the project.</span></p><p class="c2 c1"><span></span></p><p class="c1"><span>Project transaction processes SHOULD be automated, except when PyPI administrators move a project from the recently-claimed role to the claimed role. Project transaction processes MUST also be applied atomically: either all metadata and targets -- or none of them -- are added. The project transaction processes and consistent snapshot process SHOULD work concurrently. Finally, project transaction processes SHOULD keep in memory the latest claimed, recently-claimed, and unclaimed metadata so that they will be correctly updated in new consistent snapshots.</span></p><p class="c2 c1"><span></span></p><p class="c1"><span>All project transactions MAY be placed in a single queue and processed serially. Alternatively, the queue MAY be processed concurrently in order of appearance, provided that the following rules are observed:</span></p><p class="c2 c1"><span></span></p><ol class="c0 lst-kix_list_5-0 start" start="1"><li class="c9 c1"><span>No pair of project transaction processes must concurrently work on the same project.</span></li><li class="c9 c1"><span>No pair of project transaction processes must concurrently work on </span><span class="c7">unclaimed</span><span>&nbsp;projects that belong to the same delegated </span><span class="c7">unclaimed</span><span>&nbsp;role.</span></li><li class="c9 c1"><span>No pair of project transaction processes must concurrently work on new recently-claimed projects.</span></li><li class="c9 c1"><span>No pair of project transaction processes must concurrently work on new claimed projects.</span></li><li class="c9 c1"><span>No project transaction process must work on a new claimed project while another project transaction process is working on a new recently-claimed project and vice versa.</span></li></ol><p class="c2 c1 c15"><span></span></p><p class="c1 c15"><span>These rules MUST be observed to ensure that metadata is not read from or written to inconsistently.</span></p><h2 class="c12 c1"><span>Snapshot Process</span></h2><p class="c1"><span>The snapshot process is fairly simple and SHOULD be automated. The snapshot process MUST keep in memory the latest working set of </span><span class="c7">root</span><span>, </span><span class="c7">targets</span><span>, and delegated roles. Every minute or so the snapshot process will sign for this latest working set. (Recall that project transaction processes continuously inform the snapshot process about the latest delegated metadata in a concurrency-safe manner. The snapshot process will actually sign for a copy of the latest working set while the latest working set in memory will be updated with information that is continuously communicated by the project transaction processes.) The snapshot process MUST generate and sign new </span><span class="c7">timestamp</span><span>&nbsp;metadata that will vouch for the metadata (</span><span class="c7">root</span><span>, </span><span class="c7">targets</span><span>, and delegated roles) generated in the previous step. Finally, the snapshot process MUST make available to clients the new </span><span class="c7">timestamp</span><span>&nbsp;and </span><span class="c7">snapshot</span><span>&nbsp;metadata representing the latest snapshot.</span></p><p class="c2 c1"><span></span></p><p class="c1"><span>A claimed or recently-claimed project will need to upload in its transaction to PyPI not just targets (a simple index as well as distributions) but also TUF metadata. The project MAY do so by uploading a ZIP file containing two directories, /metadata/ (containing delegated targets metadata files) and /targets/ (containing targets such as the project simple index and distributions which are signed for by the delegated targets metadata).</span></p><p class="c1"><span>Whenever the project uploads metadata or targets to PyPI, PyPI SHOULD check the project TUF metadata for at least the following properties:</span></p><p class="c2 c1"><span></span></p><ul class="c0 lst-kix_list_6-0 start"><li class="c9 c1"><span>A threshold number of the developers keys registered with PyPI by that project MUST have signed for the delegated targets metadata file that represents the &quot;root&quot; of targets for that project (e.g. metadata/targets/ project.txt).</span></li><li class="c9 c1"><span>The signatures of delegated targets metadata files MUST be valid.</span></li><li class="c9 c1"><span>The delegated targets metadata files MUST NOT be expired.</span></li><li class="c1 c9"><span>The delegated targets metadata MUST be consistent with the targets.</span></li><li class="c9 c1"><span>A delegator MUST NOT delegate targets that were not delegated to itself by another delegator.</span></li><li class="c9 c1"><span>A delegatee MUST NOT sign for targets that were not delegated to itself by a delegator.</span></li><li class="c9 c1"><span>Every file MUST contain a unique copy of its hash in its filename following the filename.digest.ext convention recommended earlier.</span></li></ul><p class="c2 c1"><span></span></p><p class="c1"><span>If PyPI chooses to check the project TUF metadata, then PyPI MAY choose to reject publishing any set of metadata or targets that do not meet these requirements.</span></p><p class="c1"><span>PyPI MUST enforce access control by ensuring that each project can only write to the TUF metadata for which it is responsible. It MUST do so by ensuring that project transaction processes write to the correct metadata as well as correct locations within those metadata. For example, a project transaction process for an unclaimed project MUST write to the correct target paths in the correct delegated unclaimed metadata for the targets of the project.</span></p><p class="c2 c1"><span></span></p><p class="c1"><span>On rare occasions, PyPI MAY wish to extend the TUF metadata format for projects in a backward-incompatible manner. Note that PyPI will NOT be able to automatically rewrite existing TUF metadata on behalf of projects in order to upgrade the metadata to the new backward-incompatible format because this would invalidate the signatures of the metadata as signed by developer keys. Instead, package managers SHOULD be written to recognize and handle multiple incompatible versions of TUF metadata so that claimed and recently-claimed projects could be offered a reasonable time to migrate their metadata to newer but backward-incompatible formats.</span></p><p class="c2 c1"><span></span></p><p class="c1"><span>The details of how each project manages its TUF metadata is beyond the scope of this PEP.</span></p><p class="c2 c1"><span></span></p><p class="c1"><span>A few implementation notes are now in order. So far, we have seen that only new metadata and targets are added, but not that old metadata and targets are removed. Practical constraints are such that eventually PyPI will run out of disk space to produce a new consistent snapshot. If that happens, PyPI MAY then use something like a &quot;mark-and-sweep&quot; algorithm to delete sufficiently old consistent snapshots. Specifically, in order to preserve the latest consistent snapshot, PyPI would walk objects -- beginning from the root (</span><span class="c7">timestamp</span><span>) --of the latest consistent snapshot, mark all visited objects, and delete all unmarked objects. The last few consistent snapshots may be preserved in a similar fashion. Deleting a consistent snapshot will cause clients to see nothing except HTTP 404 responses to any request for a target of the deleted consistent snapshot. Clients SHOULD then retry (as before) their requests with the latest consistent snapshot.</span></p><p class="c2 c1"><span></span></p><p class="c1"><span>All package managers that support TUF metadata MUST be modified to download every metadata and target file (except for </span><span class="c7">timestamp</span><span>&nbsp;metadata) by including, in the request for the file, the cryptographic hash of the file in the filename. Following the filename convention recommended earlier, a request for the file at filename.ext will be transformed to the equivalent request for the file at digest.filename.</span></p><p class="c2 c13 c1"><span></span></p><p class="c13 c1"><span>Finally, PyPI SHOULD use a </span><span class="c10"><a class="c8" href="https://www.google.com/url?q=https%3A%2F%2Fgithub.com%2Ftheupdateframework%2Ftuf%2Fblob%2Fdevelop%2Ftuf%2FREADME-developer-tools.md&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNH8Bi22CSvf7jnFnSPN-ZdnKyakiQ">transaction log</a></span><span>&nbsp;to record project transaction processes and queues so that it will be easier to recover from errors after a server failure.</span></p><h1 class="c12 c1"><span>Key Compromise Analysis</span></h1><p class="c1"><span>This PEP has covered the maximum security model, the TUF roles that should be added to support continuous delivery of distributions, how to generate and sign the metadata of each role, and how to support distributions that have been signed by developers. The remaining sections discuss how PyPI SHOULD audit repository metadata and the methods PyPI can use to detect and recover from a PyPI compromise.</span></p><p class="c2 c1"><span></span></p><p class="c1"><span>Table 1 summarizes a few of the attacks possible when a threshold number of private cryptographic keys (belonging to any of the PyPI roles) are compromised. The leftmost column lists the roles (or a combination of roles) that have been compromised, and the columns to the right show whether the compromised roles leaves clients susceptible to malicious updates, freeze attacks, or metadata inconsistency attacks.</span></p><a href="#" name="161e3de1e993fe0327d3fedf757da361a2fc9f2f"></a><a href="#" name="0"></a><table cellpadding="0" cellspacing="0" class="c17"><tbody><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">Role Compromise</span></p></td><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">Malicious Updates</span></p></td><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">Freeze Attack</span></p></td><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">Metadata Inconsistency Attacks</span></p><p class="c11 c1"><span class="c5">&nbsp;</span></p></td></tr><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">timetamp</span></p></td><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">NO</span></p><p class="c11 c1"><span class="c5">snapshot and targets or any of the delegated roles need to cooperate</span></p></td><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">YES</span></p><p class="c11 c1"><span class="c5">limited by earliest root, targets, or bin metadata expiry time</span></p></td><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">NO</span></p><p class="c11 c1"><span class="c5">snapshot needs to cooperate</span></p></td></tr><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">snapshot</span></p></td><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">NO</span></p><p class="c11 c1"><span class="c5">timestamp and targets or any of the delegated roles need to cooperate</span></p></td><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">NO</span></p><p class="c11 c1"><span class="c5">timestamp needs to coorperate</span></p></td><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">NO</span></p><p class="c11 c1"><span class="c5">timestamp needs to cooperate</span></p></td></tr><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span>timestamp </span><span class="c14">AND</span><span class="c5">&nbsp;snapshot</span></p></td><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">NO</span></p><p class="c11 c1"><span class="c5">targets or any of the delegated roles need to cooperate</span></p></td><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">YES</span></p><p class="c11 c1"><span class="c5">limited by earliest root, targets, or bin metadata expiry time</span></p></td><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">YES</span></p><p class="c11 c1"><span class="c5">limited by earliest root, targets, or bin metadata expiry time</span></p></td></tr><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span>targets </span><span class="c14">OR</span><span>&nbsp;claimed </span><span class="c14 c18">OR</span></p><p class="c11 c1"><span class="c5">recently-claimed</span></p><p class="c11 c1"><span class="c14">OR</span><span>&nbsp;unclaimed </span><span class="c14">OR</span><span class="c5">&nbsp;project</span></p></td><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">NO</span></p><p class="c11 c1"><span class="c5">timestamp and snapshot need to cooperate</span></p></td><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">NOT APPLICABLE</span></p><p class="c11 c1"><span class="c5">need timestamp and snapshot</span></p></td><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">NOT APPLICABLE</span></p><p class="c11 c1"><span class="c5">need timestamp and snapshot</span></p></td></tr><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span>(timestamp </span><span class="c14">AND</span><span>&nbsp;snapshot) </span><span class="c14">AND</span><span class="c5">&nbsp;project</span></p></td><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">YES</span></p></td><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">YES</span></p><p class="c11 c1"><span class="c5">limited by earliest root, targets, or bin metadata expiry time</span></p></td><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">YES</span></p><p class="c11 c1"><span class="c5">limited by earliest root, targets, or bin metadata expiry time</span></p></td></tr><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span>(timestamp </span><span class="c14">AND</span><span>&nbsp;snapshot) </span><span class="c18 c14">AND</span></p><p class="c11 c1"><span>(recently-claimed </span><span class="c14">OR</span><span class="c5">&nbsp;unclaimed)</span></p></td><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">YES</span></p><p class="c1 c11"><span class="c5">but only of projects not delegated by claimed</span></p></td><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">YES</span></p><p class="c11 c1"><span class="c5">limited by earliest root, targets, claimed, recently-claimed, project, or unclaimed metadata expiry time</span></p></td><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">YES</span></p><p class="c11 c1"><span class="c5">limited by earliest root, targets, claimed, recently-claimed, project, or unclaimed metadata expiry time</span></p></td></tr><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span>(timestamp </span><span class="c14">AND</span><span>&nbsp;snapshot) </span><span class="c14">AND</span><span>&nbsp;(targets </span><span class="c14">OR</span><span class="c5">&nbsp;claimed)</span></p></td><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">YES</span></p></td><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">YES</span></p><p class="c11 c1"><span class="c5">limited by earliest root, targets, claimed, recently-claimed, project, or unclaimed metadata expiry time</span></p></td><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">YES</span></p><p class="c11 c1"><span class="c5">limited by earliest root, targets, claimed, recently-claimed, project, or unclaimed metadata expiry time</span></p></td></tr><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">root</span></p></td><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">YES</span></p></td><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">YES</span></p></td><td class="c4" colspan="1" rowspan="1"><p class="c11 c1"><span class="c5">YES</span></p></td></tr></tbody></table><p class="c1"><span>Table 1: Attacks that are possible by compromising certain combinations of role keys. In </span><span class="c10"><a class="c8" href="http://www.google.com/url?q=http%3A%2F%2Fdocs.python.org%2F2%2Flibrary%2Fhashlib.html%23hashlib.hash.hexdigest&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNGL1S5Bnvnl1gt4SLVy6f6nqHPhew">September 2013</a></span><span>, it was shown how the latest version (at the time) of pip was susceptible to these attacks and how TUF could protect users against them </span><span class="c3">11</span><span>.</span></p><p class="c2 c1"><span></span></p><p class="c1"><span>Note that compromising </span><span class="c7">targets</span><span>&nbsp;or any delegated role (except for project targets metadata) does not immediately allow an attacker to serve malicious updates. The attacker must also compromise the </span><span class="c7">timestamp</span><span>&nbsp;and </span><span class="c7">snapshot</span><span>&nbsp;roles (which are both online and therefore more likely to be compromised). This means that in order to launch any attack, one must not only be able to act as a man-in-the-middle but also compromise the </span><span class="c7">timestamp</span><span>&nbsp;key (or compromise the </span><span class="c7">root</span><span>&nbsp;keys and sign a new </span><span class="c7">timestamp</span><span>&nbsp;key). To launch any attack other than a freeze attack, one must also compromise the </span><span class="c7">snapshot</span><span>&nbsp;key.</span></p><p class="c2 c1 c15"><span></span></p><p class="c1 c15"><span>Finally, a compromise of the PyPI infrastructure MAY introduce malicious updates to </span><span class="c7">bins</span><span>&nbsp;projects because the keys for these roles are online. The maximum security model discussed in the appendix addresses this issue. PEP XXX [VD: Link to PEP once it is completed] also covers the maximum security model and goes into more detail on generating developer keys and signing uploaded distributions.</span></p><h2 class="c12 c1"><span>In the Event of a Key Compromise</span></h2><p class="c1"><span>A key compromise means that a threshold of keys (belonging to the metadata roles on PyPI), as well as the PyPI infrastructure, have been compromised and used to sign new metadata on PyPI.</span></p><p class="c2 c1"><span></span></p><p class="c1"><span>If a threshold number of developer keys of a project have been compromised, the project MUST take the following steps:</span></p><p class="c2 c1"><span></span></p><ol class="c0 lst-kix_list_7-0 start" start="1"><li class="c9 c1"><span>The project metadata and targets MUST be restored to the last known good consistent snapshot where the project was not known to be compromised. This can be done by developers repackaging and resigning all targets with the new keys.</span></li><li class="c9 c1"><span>The project&#39;s metadata MUST have its version numbers incremented, expiry times suitably extended, and signatures renewed.</span></li></ol><p class="c2 c1"><span></span></p><p class="c1"><span>Whereas PyPI MUST take the following steps:</span></p><p class="c2 c1"><span></span></p><ol class="c0 lst-kix_list_8-0 start" start="1"><li class="c9 c1"><span>Revoke the compromised developer keys from the </span><span class="c7">recently-claimed</span><span>&nbsp;or </span><span class="c7">claimed</span><span>&nbsp;role. This is done by replacing the compromised developer keys with newly issued developer keys.</span></li><li class="c9 c1"><span>A new timestamped consistent snapshot MUST be issued.</span></li><li class="c9 c2 c1"><span></span></li></ol><p class="c1"><span>If a threshold number of timestamp, snapshot, recently-claimed, or unclaimed keys have been compromised, then PyPI MUST take the following steps:</span></p><p class="c2 c1"><span></span></p><ol class="c0 lst-kix_list_9-0 start" start="1"><li class="c9 c1"><span>Revoke the timestamp, snapshot, and targets role keys from the root role. This is done by replacing the compromised timestamp, snapshot, and targets keys with newly issued keys.</span></li><li class="c9 c1"><span>Revoke the recently-claimed and unclaimed keys from the targets role by replacing their keys with newly issued keys. Sign the new targets role metadata and discard the new keys (because, as we explained earlier, this increases the security of targets metadata).</span></li><li class="c9 c1"><span>Clear all targets or delegations in the recently-claimed role and delete all associated delegated targets metadata. Recently registered projects SHOULD register their developer keys again with PyPI.</span></li><li class="c9 c1"><span>All targets of the recently-claimed and unclaimed roles SHOULD be compared with the last known good consistent snapshot where none of the timestamp, snapshot, recently-claimed, or unclaimed keys were known to have been compromised. Added, updated, or deleted targets in the compromised consistent snapshot that do not match the last known good consistent snapshot MAY be restored to their previous versions. After ensuring the integrity of all unclaimed targets, the unclaimed metadata MUST be regenerated.</span></li><li class="c9 c1"><span>The recently-claimed and unclaimed metadata MUST have their version numbers incremented, expiry times suitably extended, and signatures renewed.</span></li><li class="c9 c1"><span>A new timestamped consistent snapshot MUST be issued.</span></li></ol><p class="c2 c1"><span></span></p><p class="c1"><span>This would preemptively protect all of these roles even though only one of them may have been compromised.</span></p><p class="c2 c1"><span></span></p><p class="c1"><span>If a threshold number of the targets or claimed keys have been compromised, then there is little that an attacker would be able do without the timestamp and snapshot keys. In this case, PyPI MUST simply revoke the compromised targets or claimed keys by replacing them with new keys in the root and targets roles, respectively.</span></p><p class="c2 c1"><span></span></p><p class="c1"><span>If a threshold number of the timestamp, snapshot, and claimed keys have been compromised, then PyPI MUST take the following steps in addition to the steps taken when either the timestamp or snapshot keys are compromised:</span></p><p class="c2 c1"><span></span></p><ol class="c0 lst-kix_list_a-0 start" start="1"><li class="c9 c1"><span>Revoke the claimed role keys from the targets role and replace them with newly issued keys.</span></li><li class="c9 c1"><span>All project targets of the claimed roles SHOULD be compared with the last known good consistent snapshot where none of the timestamp, snapshot, or claimed keys were known to have been compromised. Added, updated, or deleted targets in the compromised consistent snapshot that do not match the last known good consistent snapshot MAY be restored to their previous versions. After ensuring the integrity of all claimed project targets, the claimed metadata MUST be regenerated.</span></li><li class="c9 c1"><span>The claimed metadata MUST have their version numbers incremented, expiry times suitably extended, and signatures renewed.</span></li></ol><p class="c2 c1"><span></span></p><p class="c1"><span>Following these steps would preemptively protect all of these roles even though only one of them may have been compromised.</span></p><p class="c2 c1"><span></span></p><p class="c1"><span>If a threshold number of </span><span class="c7">root</span><span>&nbsp;keys have been compromised, then PyPI MUST take the steps taken when the </span><span class="c7">targets</span><span>&nbsp;role has been compromised. All of the </span><span class="c7">root</span><span>&nbsp;keys must also be replaced.</span></p><p class="c2 c1 c15"><span></span></p><p class="c1 c15"><span>It is also RECOMMENDED that PyPI sufficiently document compromises with security bulletins. These security bulletins will be most informative when users of pip-with-TUF are unable to install or update a project because the keys for the </span><span class="c7">timestamp</span><span>, </span><span class="c7">snapshot</span><span>, or </span><span class="c7">root</span><span>&nbsp;roles are no longer valid. Users could then visit the PyPI web site to consult security bulletins that would help to explain why users are no longer able to install or update, and then take action accordingly. When a threshold number of </span><span class="c7">root</span><span>&nbsp;keys have not been revoked due to a compromise, then new </span><span class="c7">root</span><span>&nbsp;metadata may be safely updated because a threshold number of existing </span><span class="c7">root</span><span>&nbsp;keys will be used to sign for the integrity of the new </span><span class="c7">root</span><span>&nbsp;metadata. TUF clients will be able to verify the integrity of the new </span><span class="c7">root</span><span>&nbsp;metadata with a threshold number of previously known </span><span class="c7">root</span><span>&nbsp;keys. This will be the common case. In the worst case, where a threshold number of </span><span class="c7">root</span><span>&nbsp;keys have been revoked due to a compromise, an end-user may choose to update new </span><span class="c7">root</span><span>&nbsp;metadata with </span><span class="c10"><a class="c8" href="https://www.google.com/url?q=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FSHA-2&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNGYYBV7ICWenGECC-7BUnBRzkbl0g">out-of-band</a></span><span>&nbsp;mechanisms.</span></p><h2 class="c12 c1"><span>Auditing Snapshots</span></h2><p class="c1"><span>If a malicious party compromises PyPI, they can sign arbitrary files with any of the online keys. The roles with offline keys (i.e., </span><span class="c7">root</span><span>&nbsp;and </span><span class="c7">targets</span><span>) are still protected. To safely recover from a repository compromise, snapshots should be audited to ensure that files are only restored to trusted versions.</span></p><p class="c2 c1"><span></span></p><p class="c1"><span>When a repository compromise has been detected, the integrity of three types of information must be validated:</span></p><p class="c2 c1"><span></span></p><ol class="c0 lst-kix_list_b-0 start" start="1"><li class="c9 c1"><span>If the online keys of the repository have been compromised, they can be revoked by having the </span><span class="c7">targets</span><span>&nbsp;role sign new metadata, delegated to a new key.</span></li><li class="c9 c1"><span>If the role metadata on the repository has been changed, this will impact the metadata that is signed by online keys. Any role information created since the compromise should be discarded. As a result, developers of new projects will need to re-register their projects.</span></li><li class="c9 c1"><span>If the packages themselves may have been tampered with, they can be validated using the stored hash information for packages that existed in trusted metadata before the compromise. Also, new distributions that are signed by developers in the claimed role may be safely retained. However, any distributions signed by developers in the </span><span class="c7">recently-claimed</span><span>&nbsp;or </span><span class="c7">unclaimed</span><span>&nbsp;roles should be discarded.</span></li></ol><p class="c2 c1"><span></span></p><p class="c1"><span>In order to safely restore snapshots in the event of a compromise, PyPI SHOULD maintain a small number of its own mirrors to copy PyPI snapshots according to some schedule. The mirroring protocol can be used immediately for this purpose. The mirrors must be secured and isolated such that they are responsible only for mirroring PyPI. The mirrors can be checked against one another to detect accidental or malicious failures.</span></p><p class="c1"><span>Another approach is to generate the cryptographic hash of </span><span class="c7">snapshot</span><span>&nbsp;periodically and tweet it. For example, upon receiving the tweet, a user comes forward with the actual metadata and the repository maintainers are then able to verify the metadata&#39;s cryptographic hash. Alternatively, PyPI may periodically archive its own versions of </span><span class="c7">snapshot</span><span>&nbsp;rather than rely on externally provided metadata. In this case, PyPI SHOULD take the cryptographic hash of every package on the repository and store this data on an offline device. If any package hash has changed, this indicates an attack has occurred.</span></p><p class="c2 c1"><span></span></p><p class="c13 c1"><span>Attacks that serve different versions of metadata or that freeze a version of a package at a specific version can be handled by TUF with techniques such as implicit key revocation and metadata mismatch detection [1].</span></p><h1 class="c12 c1"><span>References</span></h1><hr><p class="c2 c1 c16"><span></span></p><ol class="c0 lst-kix_list_c-0 start" start="1"><li class="c9 c1"><span class="c10"><a class="c8" href="https://www.google.com/url?q=https%3A%2F%2Fwww.python.org%2Fdev%2Fpeps%2Fpep-0458%2F&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNFpZIaPqQsWSjss5uvMEaEmb_kiKw">https://www.python.org/dev/peps/pep-0458/</a></span><span class="c10">&#8617;</span></li><li class="c9 c1"><span class="c10"><a class="c8" href="https://www.google.com/url?q=https%3A%2F%2Fisis.poly.edu%2F~jcappos%2Fpapers%2Fsamuel_tuf_ccs_2010.pdf&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNF_y_-6kC2nB4S5cApIxnOT6xOOpw">https://isis.poly.edu/~jcappos/papers/samuel_tuf_ccs_2010.pdf</a></span><span class="c10">&#8617;</span></li><li class="c9 c1"><span class="c10"><a class="c8" href="https://www.google.com/url?q=https%3A%2F%2Fisis.poly.edu%2F~jcappos%2Fpapers%2Fsamuel_tuf_ccs_2010.pdf&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNF_y_-6kC2nB4S5cApIxnOT6xOOpw">https://isis.poly.edu/~jcappos/papers/samuel_tuf_ccs_2010.pdf</a></span><span class="c10">&#8617;</span></li><li class="c9 c1"><span class="c10"><a class="c8" href="https://www.google.com/url?q=https%3A%2F%2Fgithub.com%2Ftheupdateframework%2Ftuf%2Fblob%2Fdevelop%2Fdocs%2Ftuf-spec.txt&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNG8HXuA6f68Nu6Ih2pweI1wcJzRJQ">https://github.com/theupdateframework/tuf/blob/develop/docs/tuf-spec.txt</a></span><span class="c10">&#8617;</span></li><li class="c9 c1"><span class="c10"><a class="c8" href="https://www.google.com/url?q=https%3A%2F%2Fwww.python.org%2Fdev%2Fpeps%2Fpep-0458%2F&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNFpZIaPqQsWSjss5uvMEaEmb_kiKw">https://www.python.org/dev/peps/pep-0458/</a></span><span class="c10">&#8617;</span></li><li class="c9 c1"><span class="c10"><a class="c8" href="http://www.google.com/url?q=http%3A%2F%2Fwww.python.org%2Fdev%2Fpeps%2Fpep-0426%2F&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNHbBYfTd1hN6mE3IhGj-VY9dFwQkw">http://www.python.org/dev/peps/pep-0426/</a></span><span class="c10">&#8617;</span></li><li class="c9 c1"><span class="c10"><a class="c8" href="http://www.google.com/url?q=http%3A%2F%2Fwww.python.org%2Fdev%2Fpeps%2Fpep-0426%2F&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNHbBYfTd1hN6mE3IhGj-VY9dFwQkw">http://www.python.org/dev/peps/pep-0426/</a></span><span class="c10">&#8617;</span></li><li class="c9 c1"><span class="c10"><a class="c8" href="http://www.google.com/url?q=http%3A%2F%2Fwww.python.org%2Fdev%2Fpeps%2Fpep-0426%2F&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNHbBYfTd1hN6mE3IhGj-VY9dFwQkw">http://www.python.org/dev/peps/pep-0426/</a></span><span class="c10">&#8617;</span></li><li class="c9 c1"><span class="c10"><a class="c8" href="https://www.google.com/url?q=https%3A%2F%2Fwww.python.org%2Fdev%2Fpeps%2Fpep-0458%2F&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNFpZIaPqQsWSjss5uvMEaEmb_kiKw">https://www.python.org/dev/peps/pep-0458/</a></span><span class="c10">&#8617;</span></li><li class="c9 c1"><span class="c10"><a class="c8" href="https://www.google.com/url?q=https%3A%2F%2Fgithub.com%2Ftheupdateframework%2Ftuf%2Fblob%2Fdevelop%2Fdocs%2Ftuf-spec.txt&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNG8HXuA6f68Nu6Ih2pweI1wcJzRJQ">https://github.com/theupdateframework/tuf/blob/develop/docs/tuf-spec.txt</a></span><span class="c10">&#8617;</span></li><li class="c9 c1"><span class="c10"><a class="c8" href="https://www.google.com/url?q=https%3A%2F%2Fmail.python.org%2Fpipermail%2Fdistutils-sig%2F2013-September%2F022755.html&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNGCFzaSrI2lc6bKuHkiSTrROp18cg">https://mail.python.org/pipermail/distutils-sig/2013-September/022755.html</a></span><span class="c10">&#8617;</span></li></ol><p class="c2 c1"><span class="c10"></span></p><h1 class="c13 c1"><span>Acknowledgements</span></h1><p class="c1"><span>This material is based upon work supported by the National Science Foundation under Grant No. CNS-1345049 and CNS-0959138. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the National Science Foundation.</span></p><p class="c1"><span>Nick Coghlan, Daniel Holth and the distutils-sig community in general for helping us to think about how to usably and efficiently integrate TUF with PyPI.</span></p><p class="c1"><span>Roger Dingledine, Sebastian Hahn, Nick Mathewson, Martin Peck and Justin Samuel for helping us to design TUF from its predecessor Thandy of the Tor project.</span></p><p class="c13 c1"><span>Konstantin Andrianov, Geremy Condra, Vladimir Diaz, Zane Fisher, Justin Samuel, Tian Tian, Santiago Torres, John Ward, and Yuyu Zheng for helping us to develop TUF.</span></p><h1 class="c13 c1"><a name="h.5kwq64w7bbrv"></a><span>Copyright</span></h1><p class="c1"><span>This document has been placed in the public domain.</span></p></body></html>